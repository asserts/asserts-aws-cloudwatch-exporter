/*
 *  Copyright Â© 2022.
 *  Asserts, Inc. - All Rights Reserved
 */
package ai.asserts.aws.cloudwatch.alarms;

import ai.asserts.aws.ObjectMapperFactory;
import ai.asserts.aws.ScrapeConfigProvider;
import ai.asserts.aws.config.ScrapeConfig;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.core.JsonProcessingException;
import lombok.AllArgsConstructor;
import lombok.Getter;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;
import org.springframework.util.CollectionUtils;
import org.springframework.util.StringUtils;
import software.amazon.awssdk.services.cloudwatch.model.MetricAlarm;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;

import static ai.asserts.aws.MetricNameUtil.SCRAPE_ACCOUNT_ID_LABEL;
import static ai.asserts.aws.MetricNameUtil.SCRAPE_REGION_LABEL;
import static io.micrometer.core.instrument.util.StringUtils.isEmpty;
import static org.springframework.util.StringUtils.hasLength;

@Component
@Slf4j
@AllArgsConstructor
public class AlarmMetricConverter {
    private static final Pattern AUTOGENERATED_ALARM_NAME = Pattern.compile("TargetTracking-.+/(.+)-Alarm(.+?)-.+");
    private final ScrapeConfigProvider scrapeConfigProvider;
    private final ObjectMapperFactory objectMapperFactory;

    public List<Map<String, String>> convertAlarm(AlarmStateChange alarmStateChange) {
        List<Map<String, String>> labelsList = new ArrayList<>();
        if (alarmStateChange.getDetail() != null) {
            if (isConfigMetricAvailable(alarmStateChange)) {
                List<Map<String, String>> fieldsValue = getDimensionFields(alarmStateChange);
                if (!CollectionUtils.isEmpty(fieldsValue)) {
                    fieldsValue.forEach(values -> {
                        SortedMap<String, String> labels = new TreeMap<>();
                        if (alarmStateChange.getRegion() != null) {
                            labels.put(SCRAPE_REGION_LABEL, alarmStateChange.getRegion());
                        }
                        if (alarmStateChange.getAccount() != null) {
                            labels.put(SCRAPE_ACCOUNT_ID_LABEL, alarmStateChange.getAccount());
                        }
                        if (alarmStateChange.getDetail().getAlarmName() != null) {
                            labels.put("alarm_name", alarmStateChange.getDetail().getAlarmName());
                        }
                        if (alarmStateChange.getDetail().getState() != null
                                && alarmStateChange.getDetail().getState().getValue() != null) {
                            labels.put("state", alarmStateChange.getDetail().getState().getValue());
                        }
                        if (alarmStateChange.getTime() != null) {
                            labels.put("timestamp", alarmStateChange.getTime());
                        }
                        labels.putAll(values);
                        if (alarmStateChange.getDetail().getState().getReasonData() != null) {
                            Optional<String> threshold = parseThreshold(alarmStateChange.getDetail().getState()
                                    .getReasonData());
                            threshold.map(k -> labels.put("threshold", k));
                        }
                        simplifyAlarmName(labels);
                        labelsList.add(labels);
                    });
                }
            }
        } else {
            log.error("Unable to process Alarms - {}", String.join(",", alarmStateChange.getResources()));
        }
        return labelsList;
    }

    public void simplifyAlarmName(Map<String, String> labels) {
        if (labels.containsKey("alarm_name")) {
            String originalAlarmName = labels.get("alarm_name");
            String alarmName = originalAlarmName;

            // Example
            // TargetTracking-table/GameScores/index/GameTitle-TopScore-index-AlarmLow-700cf83c-e41f-4349-a94a-88da343f4823
            Matcher matcher = AUTOGENERATED_ALARM_NAME.matcher(alarmName);
            if (matcher.matches()) {
                alarmName = matcher.group(1) + " " + labels.get("metric_name") + " " + matcher.group(2);
            }

            String jobName = labels.get("job");
            if (StringUtils.hasLength(jobName)) {
                if (alarmName.contains(jobName + "-")) {
                    alarmName = alarmName.replace(jobName + "-", "");
                } else if (alarmName.contains(jobName + "/")) {
                    alarmName = alarmName.replace(jobName + "/", "");
                } else if (alarmName.contains(jobName)) {
                    alarmName = alarmName.replace(jobName, "");
                }
            }

            if (!alarmName.equals(originalAlarmName)) {
                labels.put("original_alarm_name", originalAlarmName);
                labels.put("alarm_name", alarmName.trim());
                labels.put("alertname", alarmName.trim());
            } else {
                labels.put("alertname", alarmName.trim());
            }
        }
    }

    Map<String, String> extractMetricAndEntityLabels(MetricAlarm metric) {
        Map<String, String> labels = new TreeMap<>();

        labels.put("alarm_name", metric.alarmName());
        labels.put("namespace", metric.namespace());
        labels.put("metric_namespace", metric.namespace());
        labels.put("metric_name", metric.metricName());
        labels.put("metric_stat", metric.statisticAsString());
        labels.put("metric_period", Integer.toString(metric.period()));

        ScrapeConfig scrapeConfig = scrapeConfigProvider.getScrapeConfig();

        SortedMap<String, String> dimensionAsMap = new TreeMap<>();
        metric.dimensions().forEach(d -> dimensionAsMap.put(d.name(), d.value()));
        labels.putAll(scrapeConfig.getEntityLabels(metric.namespace(), dimensionAsMap));

        dimensionAsMap.forEach((key, value) -> labels.put("d_" + key, value));
        return labels;
    }

    private List<Map<String, String>> getDimensionFields(AlarmStateChange alarmStateChange) {
        return alarmStateChange.getDetail().
                getConfiguration().getMetrics().
                stream().map(this::extractMetricAndEntityLabels)
                .collect(Collectors.toList());
    }

    private boolean isConfigMetricAvailable(AlarmStateChange alarmStateChange) {
        return alarmStateChange.getDetail().getConfiguration() != null &&
                alarmStateChange.getDetail().getConfiguration().getMetrics() != null;
    }

    private Map<String, String> extractMetricAndEntityLabels(AlarmMetrics metric) {
        Map<String, String> labels = new TreeMap<>();
        AlarmMetricStat metricStat = metric.getMetricStat();
        if (metricStat != null && metricStat.getMetric() != null) {
            AlarmMetric alarmMetric = metricStat.getMetric();

            if (alarmMetric.getNamespace() != null) {
                labels.put("namespace", alarmMetric.getNamespace());
                labels.put("metric_namespace", alarmMetric.getNamespace());
            }

            if (alarmMetric.getName() != null) {
                labels.put("metric_name", alarmMetric.getName());
            }

            if (metricStat.getStat() != null) {
                labels.put("metric_stat", metricStat.getStat());
            }

            if (metricStat.getPeriod() != null) {
                labels.put("metric_period", metricStat.getPeriod().toString());
            }

            if (hasLength(alarmMetric.getNamespace()) && hasLength(metricStat.getMetric().getName())) {
                ScrapeConfig scrapeConfig = scrapeConfigProvider.getScrapeConfig();
                labels.putAll(scrapeConfig.getEntityLabels(alarmMetric.getNamespace(), alarmMetric.getDimensions()));
            }

            if (!CollectionUtils.isEmpty(alarmMetric.getDimensions())) {
                alarmMetric.getDimensions().forEach((key, value) -> labels.put("d_" + key, value));
            }
        }
        return labels;
    }

    private Optional<String> parseThreshold(String reasonData) {
        try {
            ReasonData reasonDataObj = objectMapperFactory.getObjectMapper().readValue(reasonData, ReasonData.class);
            if (!isEmpty(reasonDataObj.getThreshold())) {
                return Optional.of(reasonDataObj.getThreshold());
            }
        } catch (JsonProcessingException e) {
            throw new RuntimeException(e);
        }
        return Optional.empty();
    }

    @Getter
    @Setter
    @JsonIgnoreProperties(ignoreUnknown = true)
    public static class ReasonData {
        private String threshold;
    }
}
